# Generated by AI - Python Module

"""
Main export module - PydocsExporter
===================================

Manages complete export of pydocs documentation
in different formats.
"""

import os
import sys
import pydoc
import json
import html
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from datetime import datetime
import textwrap

from .formatter import (TextFormatter, PDFFormatter, EbookFormatter,
                        RTFFormatter, XMLFormatter, JSONFormatter,
                        CSVFormatter, HLPFormatter, MDFormatter,
                        RSTFormatter, AZWFormatter, DOCXFormatter,
                        YAMLFormatter, SQLiteFormatter)
from .index_manager import IndexManager


class PydocsExporter:
    """Main exporter for pydocs documentation."""

    # Supported paper sizes
    PAPER_SIZES = {
        "A0": (2384, 3370),
        "A1": (1684, 2384),
        "A2": (1191, 1684),
        "A3": (842, 1191),
        "A4": (595, 842),
        "A5": (420, 595),
        "A6": (298, 420),
        "A7": (210, 298),
        "A8": (148, 210),
        "A9": (105, 148),
        "A10": (73, 105),
    }

    def __init__(self, output_base_dir: str = "pydocs_export_output"):
        """
        Initialize the exporter.

        Args:
            output_base_dir: Base directory for exports
        """
        self.output_base = Path(output_base_dir)
        self.output_base.mkdir(parents=True, exist_ok=True)
        # Create subdirectories for each format
        self.txt_dir = self.output_base / "TXT"
        self.pdf_dir = self.output_base / "PDF"
        self.epub_dir = self.output_base / "EBOOK_EPUB"
        self.mobi_dir = self.output_base / "EBOOK_MOBI"
        self.rtf_dir = self.output_base / "RTF"
        self.html_dir = self.output_base / "HTML"
        self.xml_dir = self.output_base / "XML"
        self.json_dir = self.output_base / "JSON"
        self.csv_dir = self.output_base / "CSV"
        self.hlp_dir = self.output_base / "HLP"
        self.md_dir = self.output_base / "MARKDOWN"
        self.rst_dir = self.output_base / "RESTRUCTUREDTEXT"
        self.azw_dir = self.output_base / "AZW"
        self.docx_dir = self.output_base / "DOCX"
        self.yaml_dir = self.output_base / "YAML"
        self.sqlite_dir = self.output_base / "SQLITE"

        dirs = [self.txt_dir, self.pdf_dir, self.epub_dir,
                self.mobi_dir, self.rtf_dir, self.html_dir,
                self.xml_dir, self.json_dir, self.csv_dir, self.hlp_dir,
                self.md_dir, self.rst_dir, self.azw_dir, self.docx_dir,
                self.yaml_dir, self.sqlite_dir]
        for d in dirs:
            d.mkdir(parents=True, exist_ok=True)

        self.index_manager = IndexManager()
        self.text_formatter = TextFormatter()
        self.pdf_formatter = PDFFormatter()
        self.ebook_formatter = EbookFormatter()
        self.rtf_formatter = RTFFormatter()
        self.xml_formatter = XMLFormatter()
        self.json_formatter = JSONFormatter()
        self.csv_formatter = CSVFormatter()
        self.hlp_formatter = HLPFormatter()
        self.md_formatter = MDFormatter()
        self.rst_formatter = RSTFormatter()
        self.azw_formatter = AZWFormatter()
        self.docx_formatter = DOCXFormatter()
        self.yaml_formatter = YAMLFormatter()
        self.sqlite_formatter = SQLiteFormatter()

        self.export_log = []
        self.timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

    def export_all(self, formats: Optional[List[str]] = None) -> Dict:
        """
        Exports documentation in all specified formats.

        Args:
            formats: List of formats ('txt', 'pdf', 'epub', 'mobi', 
                    'rtf', 'html'). If None, all formats are exported.

        Returns:
            Dictionary with export statistics
        """
        if formats is None:
            formats = ["txt", "pdf", "epub", "mobi", "rtf", "html"]

        results = {
            "timestamp": self.timestamp,
            "formats": {},
            "total_modules": 0,
            "errors": [],
        }

        # Get list of all modules
        modules = self._get_all_modules()
        results["total_modules"] = len(modules)

        msg1 = f"[INFO] Starting export of {len(modules)} modules"
        print(msg1)
        msg2 = f"[INFO] Formats: {', '.join(formats)}"
        print(msg2)

        for fmt in formats:
            try:
                if fmt.lower() == "txt":
                    result = self._export_txt(modules)
                    results["formats"]["txt"] = result
                elif fmt.lower() == "pdf":
                    result = self._export_pdf(modules)
                    results["formats"]["pdf"] = result
                elif fmt.lower() == "epub":
                    result = self._export_epub(modules)
                    results["formats"]["epub"] = result
                elif fmt.lower() == "mobi":
                    result = self._export_mobi(modules)
                    results["formats"]["mobi"] = result
                elif fmt.lower() == "rtf":
                    result = self._export_rtf(modules)
                    results["formats"]["rtf"] = result
                elif fmt.lower() == "html":
                    result = self._export_html(modules)
                    results["formats"]["html"] = result
                elif fmt.lower() == "xml":
                    result = self._export_xml(modules)
                    results["formats"]["xml"] = result
                elif fmt.lower() == "json":
                    result = self._export_json(modules)
                    results["formats"]["json"] = result
                elif fmt.lower() == "csv":
                    result = self._export_csv(modules)
                    results["formats"]["csv"] = result
                elif fmt.lower() == "hlp":
                    result = self._export_hlp(modules)
                    results["formats"]["hlp"] = result
                elif fmt.lower() == "md" or fmt.lower() == "markdown":
                    result = self._export_md(modules)
                    results["formats"]["md"] = result
                elif fmt.lower() == "rst" or fmt.lower() == \
                        "restructuredtext":
                    result = self._export_rst(modules)
                    results["formats"]["rst"] = result
                elif fmt.lower() == "azw":
                    result = self._export_azw(modules)
                    results["formats"]["azw"] = result
                elif fmt.lower() == "docx":
                    result = self._export_docx(modules)
                    results["formats"]["docx"] = result
                elif fmt.lower() == "yaml" or fmt.lower() == "yml":
                    result = self._export_yaml(modules)
                    results["formats"]["yaml"] = result
                elif fmt.lower() == "sqlite" or fmt.lower() == "db":
                    result = self._export_sqlite(modules)
                    results["formats"]["sqlite"] = result
                else:
                    msg = f"[WARNING] Unknown format: {fmt}"
                    print(msg)
                    results["warnings"].append(msg)
            except Exception as e:
                error_msg = f"Error exporting {fmt}: {str(e)}"
                results["errors"].append(error_msg)
                print(f"[ERROR] {error_msg}")

        # Create general index file
        self._create_index(modules, results)

        # Save log
        self._save_log(results)

        print(f"\n[SUCC√àS] Exportation termin√©e!")
        print(f"[INFO] Fichiers cr√©√©s: {results}")

        return results

    def _get_all_modules(self) -> List[str]:
        """
        Retrieves list of all available Python modules.
        Includes built-in, installed, and system modules.
        Filters out external URLs and non-HTML files.
        """
        modules = set()
        try:
            # Get built-in modules
            import builtins
            for name in dir(builtins):
                if not name.startswith("_"):
                    modules.add(name)

            # Get all modules from sys.modules
            for name in sys.modules.keys():
                # Filter out external URLs and non-HTML files
                if (name.startswith("_") or
                    name.startswith("http://") or
                    name.startswith("https://") or
                    name.endswith(".html") or
                    "/" in name or
                    "\\" in name):
                    continue
                # Add both top-level and some dotted names
                if "." not in name:
                    modules.add(name)
                else:
                    # Add main package (e.g., 'os.path' -> 'os')
                    main_pkg = name.split(".")[0]
                    if (not main_pkg.startswith("_") and
                        not main_pkg.startswith("http")):
                        modules.add(main_pkg)

            # Add standard library modules
            import pkgutil
            for importer, name, ispkg in pkgutil.iter_modules():
                # Filter out invalid names
                if (not name.startswith("_") and
                    "/" not in name and
                    "\\" not in name and
                    not name.startswith("http")):
                    modules.add(name)

        except Exception as e:
            print(f"[WARNING] Error retrieving modules: {e}")

        return sorted(list(modules))

    def _format_progress(self, current: int, total: int) -> str:
        """
        Formats progress as percentage with bar.
        
        Args:
            current: Current item number
            total: Total items
            
        Returns:
            Formatted progress string with percentage
        """
        if total <= 0:
            return "0%"
        
        percentage = (current / total) * 100
        bar_length = 30
        filled_length = int(bar_length * current // total)
        bar = "‚ñà" * filled_length + "‚ñë" * (bar_length - filled_length)
        
        return (f"{current}/{total} [{bar}] "
                f"{percentage:.1f}%")

    def _get_module_full_help(
        self,
        module_name: str
    ) -> str:
        """
        Gets complete help documentation for a module.
        Uses pydoc to retrieve help WITHOUT actually importing
        the module, avoiding side effects like launching web servers.
        Suppresses any output from module initialization.

        Args:
            module_name: Name of the module

        Returns:
            Complete help text including docstring and help
        """
        help_text = ""
        try:
            # Suppress stdout/stderr during documentation generation
            # to avoid module initialization messages
            import io
            import contextlib
            
            # Redirect both stdout and stderr
            stdout_capture = io.StringIO()
            stderr_capture = io.StringIO()
            
            with contextlib.redirect_stdout(stdout_capture), \
                 contextlib.redirect_stderr(stderr_capture):
                # Use pydoc to get documentation WITHOUT importing
                # pydoc.render_doc uses introspection, not importlib
                doc = self._get_module_doc_silent(module_name, renderer=pydoc.TextDoc())
            
            if doc:
                help_text = doc
            else:
                help_text = (
                    f"[No documentation available for "
                    f"{module_name}]\n"
                )

        except Exception as e:
            help_text = (
                f"[Error retrieving help for {module_name}: {e}]\n"
            )

        return help_text

    def _get_module_doc_silent(
        self,
        module_name: str,
        renderer=None
    ) -> str:
        """
        Gets documentation for a module using pydoc,
        suppressing all output to stdout/stderr.

        Args:
            module_name: Name of the module
            renderer: pydoc renderer (TextDoc, HTMLDoc, etc.)

        Returns:
            Documentation text or empty string
        """
        if renderer is None:
            renderer = pydoc.TextDoc()
        
        try:
            import io
            import contextlib
            
            # Suppress stdout/stderr during documentation generation
            stdout_capture = io.StringIO()
            stderr_capture = io.StringIO()
            
            with contextlib.redirect_stdout(stdout_capture), \
                 contextlib.redirect_stderr(stderr_capture):
                doc = pydoc.render_doc(
                    module_name,
                    renderer=renderer
                )
            
            return doc if doc else ""
            
        except Exception as e:
            # Silently return empty string on error
            return ""

    def _export_txt(self, modules: List[str]) -> Dict:
        """Exports documentation in TXT format."""
        print("\n[TXT] Starting TXT export...")

        stats = {
            "format": "TXT",
            "files_created": 0,
            "total_size": 0,
            "chapters": [],
        }

        # Create chapters directory
        chapters_dir = self.txt_dir / "Chapters"
        chapters_dir.mkdir(parents=True, exist_ok=True)

        for i, module_name in enumerate(modules, 1):
            try:
                # Get documentation from pydoc (silent)
                doc = self._get_module_doc_silent(
                    module_name,
                    renderer=pydoc.TextDoc()
                )

                # Get full help text
                help_text = self._get_module_full_help(module_name)

                # Combine documentation and help
                combined_content = ""
                combined_content += "=" * 80 + "\n"
                combined_content += f"MODULE: {module_name}\n"
                combined_content += "=" * 80 + "\n\n"

                combined_content += "PYDOC DOCUMENTATION\n"
                combined_content += "-" * 80 + "\n"
                combined_content += doc if doc else "No documentation\n"

                combined_content += "\n\n"
                combined_content += "FULL HELP\n"
                combined_content += "-" * 80 + "\n"
                combined_content += help_text

                # Create one file per module
                filename = f"{i:03d}_{module_name}.txt"
                filepath = chapters_dir / filename

                with open(filepath, "w", encoding="utf-8") as f:
                    f.write(combined_content)

                file_size = filepath.stat().st_size
                stats["files_created"] += 1
                stats["total_size"] += file_size
                stats["chapters"].append({
                    "name": module_name,
                    "file": filename,
                    "size": file_size,
                })

                if i % 5 == 0 or i == len(modules):
                    progress = self._format_progress(i, len(modules))
                    print(f"  [TXT] {progress}")

            except Exception as e:
                msg = f"  [WARNING] Cannot export {module_name}"
                print(msg + f": {e}")

        print(f"[TXT] {stats['files_created']} files created")
        return stats

    def _export_pdf(self, modules: List[str]) -> Dict:
        """Exporte la documentation en format PDF avec support multi-formats."""
        print("\n[PDF] D√©but de l'exportation PDF...")

        stats = {
            "format": "PDF",
            "paper_sizes": {},
            "total_files": 0,
        }

        for paper_size in self.PAPER_SIZES.keys():
            try:
                pdf_subdir = self.pdf_dir / paper_size
                pdf_subdir.mkdir(parents=True, exist_ok=True)

                # Cr√©er un fichier PDF principal par format de papier
                pdf_filename = f"Python_Documentation_{paper_size}_{self.timestamp}.txt"
                pdf_filepath = pdf_subdir / pdf_filename

                content = self._generate_pdf_content(modules, paper_size)

                with open(pdf_filepath, "w", encoding="utf-8") as f:
                    f.write(content)

                stats["paper_sizes"][paper_size] = {
                    "file": pdf_filename,
                    "size": pdf_filepath.stat().st_size,
                }
                stats["total_files"] += 1

                print(f"  [PDF] Format {paper_size} cr√©√©")

            except Exception as e:
                print(f"  [ERREUR] Impossible de cr√©er PDF {paper_size}: {e}")

        return stats

    def _export_epub(self, modules: List[str]) -> Dict:
        """Exporte la documentation en format EPUB."""
        print("\n[EPUB] D√©but de l'exportation EPUB...")

        stats = {
            "format": "EPUB",
            "files_created": 1,
            "filename": f"Python_Documentation_{self.timestamp}.epub",
        }

        try:
            # Cr√©er une structure EPUB simple
            epub_content = self._generate_epub_structure(modules)
            epub_path = self.epub_dir / stats["filename"]

            with open(epub_path, "w", encoding="utf-8") as f:
                f.write(epub_content)

            print(f"[EPUB] Fichier cr√©√©: {stats['filename']}")

        except Exception as e:
            print(f"[ERREUR EPUB] {e}")
            stats["error"] = str(e)

        return stats

    def _export_mobi(self, modules: List[str]) -> Dict:
        """Exporte la documentation en format MOBI."""
        print("\n[MOBI] D√©but de l'exportation MOBI...")

        stats = {
            "format": "MOBI",
            "files_created": 1,
            "filename": f"Python_Documentation_{self.timestamp}.mobi",
        }

        try:
            mobi_content = self._generate_mobi_structure(modules)
            mobi_path = self.mobi_dir / stats["filename"]

            with open(mobi_path, "w", encoding="utf-8") as f:
                f.write(mobi_content)

            print(f"[MOBI] Fichier cr√©√©: {stats['filename']}")

        except Exception as e:
            print(f"[ERREUR MOBI] {e}")
            stats["error"] = str(e)

        return stats

    def _export_html(self, modules: List[str]) -> Dict:
        """Exporte la documentation en format HTML."""
        print("\n[HTML] D√©but de l'exportation HTML...")

        stats = {
            "format": "HTML",
            "files_created": 0,
            "index": "index.html",
        }

        try:
            # Cr√©er un fichier index
            html_content = self._generate_html_index(modules)
            index_path = self.html_dir / "index.html"

            with open(index_path, "w", encoding="utf-8") as f:
                f.write(html_content)

            stats["files_created"] = 1

            # Cr√©er un fichier par module
            for i, module_name in enumerate(modules, 1):
                try:
                    doc = self._get_module_doc_silent(
                        module_name, renderer=pydoc.HTMLDoc())
                    if doc:
                        filename = f"{i:03d}_{module_name}.html"
                        filepath = self.html_dir / filename

                        with open(filepath, "w", encoding="utf-8") as f:
                            f.write(doc)

                        stats["files_created"] += 1

                except Exception as e:
                    pass

            print(f"[HTML] {stats['files_created']} fichiers HTML cr√©√©s")

        except Exception as e:
            print(f"[ERREUR HTML] {e}")
            stats["error"] = str(e)

        return stats

    def _generate_pdf_content(self, modules: List[str], paper_size: str) -> str:
        """G√©n√®re le contenu pour un PDF (simulation avec TXT)."""
        width, height = self.PAPER_SIZES[paper_size]

        content = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    PYTHON DOCUMENTATION EXPORT                               ‚ïë
‚ïë                    Format Papier: {paper_size:^56} ‚ïë
‚ïë                    Dimensions: {width}x{height} points{" " * (48 - len(str(width)) - len(str(height)))} ‚ïë
‚ïë                    G√©n√©r√© le: {datetime.now().strftime('%Y-%m-%d %H:%M:%S'):^50} ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

TABLE DES MATI√àRES - Format {paper_size}
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

"""
        for i, module_name in enumerate(modules, 1):
            content += f"{i:3d}. {module_name}\n"

        content += "\n" + "=" * 80 + "\n\nCONTENU PRINCIPAL\n" + "=" * 80 + "\n\n"

        for i, module_name in enumerate(modules, 1):
            try:
                doc = self._get_module_doc_silent(
                    module_name, renderer=pydoc.TextDoc())
                if doc:
                    content += f"\n\n{'=' * 80}\n"
                    content += f"CHAPITRE {i}: {module_name.upper()}\n"
                    content += f"{'=' * 80}\n\n"
                    content += doc[:1000]  # Limiter √† 1000 caract√®res par module
                    content += f"\n...\n[Documentation compl√®te du module {module_name}]\n"
            except:
                pass

        return content

    def _generate_epub_structure(self, modules: List[str]) -> str:
        """Generates EPUB structure with full documentation."""
        epub_content = """<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Python Documentation - EPUB</title>
    <meta charset="utf-8" />
    <style>
        body { font-family: Georgia, serif; line-height: 1.6; }
        h1 { font-size: 2em; margin-top: 1em; }
        h2 { font-size: 1.5em; margin-top: 0.8em; }
        code { font-family: monospace; background: #f0f0f0; }
    </style>
</head>
<body>
<h1>Python Complete Documentation - EPUB Format</h1>

"""
        for i, module_name in enumerate(modules, 1):
            epub_content += f"""
<h2>Chapter {i}: {module_name}</h2>
"""
            try:
                # Get pydoc documentation
                doc = self._get_module_doc_silent(module_name, renderer=pydoc.TextDoc())
                if doc:
                    safe_doc = html.escape(doc[:800])
                    epub_content += f"<pre>{safe_doc}</pre>"

                # Get full help
                help_text = self._get_module_full_help(
                    module_name
                )
                if help_text:
                    safe_help = html.escape(help_text[:1500])
                    epub_content += (
                        f"<h3>Full Help</h3><pre>"
                        f"{safe_help}</pre>"
                    )

            except Exception:
                epub_content += (
                    f"<p>Error for {module_name}</p>\n"
                )

        epub_content += """
</body>
</html>
"""
        return epub_content

    def _generate_mobi_structure(self, modules: List[str]) -> str:
        """Generates MOBI structure with full documentation."""
        mobi_content = (
            "[MOBI Format - Python Documentation]\n\n"
            "TITLE: Python Complete Documentation\n"
            "AUTHOR: Python Documentation Export\n"
            f"DATE: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
            "TABLE OF CONTENTS\n"
            "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
            "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n"
        )

        for i, module_name in enumerate(modules, 1):
            mobi_content += f"{i:3d}. {module_name}\n"

        mobi_content += (
            "\n" + "=" * 80 +
            "\nCONTENT\n" + "=" * 80 + "\n"
        )

        for i, module_name in enumerate(modules, 1):
            mobi_content += f"\n\nChapter {i}: {module_name}\n"
            mobi_content += "-" * 40 + "\n"
            try:
                # Get pydoc documentation
                doc = self._get_module_doc_silent(module_name, renderer=pydoc.TextDoc())
                if doc:
                    mobi_content += doc[:800] + "\n"

                # Get full help
                help_text = self._get_module_full_help(
                    module_name
                )
                if help_text:
                    mobi_content += "\n[FULL HELP]\n"
                    mobi_content += help_text[:1000] + "\n"

            except Exception:
                msg = f"[Error loading {module_name}]\n"
                mobi_content += msg

        return mobi_content

    def _export_rtf(self, modules: List[str]) -> Dict:
        """Exports documentation in RTF format."""
        print("\n[RTF] Starting RTF export...")

        stats = {
            "format": "RTF",
            "files_created": 0,
            "total_size": 0,
            "chapters": [],
        }

        # Create chapters directory
        chapters_dir = self.rtf_dir / "Chapters"
        chapters_dir.mkdir(parents=True, exist_ok=True)

        for i, module_name in enumerate(modules, 1):
            try:
                # Get documentation
                doc = self._get_module_doc_silent(module_name, renderer=pydoc.TextDoc())

                # Get full help
                help_text = self._get_module_full_help(
                    module_name
                )

                # Combine both
                combined_text = ""
                combined_text += f"Module: {module_name}\n\n"
                combined_text += "PYDOC DOCUMENTATION\n"
                combined_text += "-" * 40 + "\n"
                combined_text += doc if doc else "No documentation"
                combined_text += "\n\nFULL HELP\n"
                combined_text += "-" * 40 + "\n"
                combined_text += help_text

                if combined_text:
                    # Create one file per module
                    filename = f"{i:03d}_{module_name}.rtf"
                    filepath = chapters_dir / filename

                    # Format as RTF
                    rtf_content = (
                        self.rtf_formatter.format_module_doc(
                            module_name,
                            combined_text
                        )
                    )

                    with open(filepath, "w", encoding="utf-8") as f:
                        f.write(rtf_content)

                    file_size = filepath.stat().st_size
                    stats["files_created"] += 1
                    stats["total_size"] += file_size
                    stats["chapters"].append({
                        "name": module_name,
                        "file": filename,
                        "size": file_size,
                    })

                    if i % 5 == 0 or i == len(modules):
                        progress = self._format_progress(
                            i, len(modules))
                        print(f"  [RTF] {progress}")

            except Exception as e:
                msg = f"  [WARNING] Cannot export {module_name}: {e}"
                print(msg)

        print(f"[RTF] {stats['files_created']} files created")
        return stats

    def _generate_html_index(self, modules: List[str]) -> str:
        """Generates an HTML index."""
        html_content = """<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Documentation - Index</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #667eea;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }
        h2 {
            color: #764ba2;
            margin-top: 30px;
        }
        .module-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .module-item {
            background: #f8f9fa;
            padding: 15px;
            border-left: 4px solid #667eea;
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        .module-item:hover {
            background: #e9ecef;
            transform: translateX(5px);
        }
        .module-item a {
            text-decoration: none;
            color: #667eea;
            font-weight: 600;
        }
        .module-item a:hover {
            text-decoration: underline;
        }
        .info {
            color: #6c757d;
            font-size: 0.9em;
            margin-top: 20px;
        }
        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìö Python Documentation - Complete Index</h1>
        <p>Generated: """ + datetime.now().strftime("%Y-%m-%d %H:%M:%S") + """</p>

        <h2>üìñ Available Modules</h2>
        <div class="module-list">
"""
        for i, module_name in enumerate(modules, 1):
            html_content += f"""            <div class="module-item">
                <a href="{i:03d}_{module_name}.html">{module_name}</a>
                <p style="margin: 5px 0 0 0; color: #999; font-size: 0.85em;">Module {i}/{len(modules)}</p>
            </div>
"""

        html_content += """        </div>

        <h2>üìä Statistics</h2>
        <ul>
            <li>Total Modules: """ + str(len(modules)) + """</li>
            <li>Export Date: """ + datetime.now().strftime("%d-%m-%Y %H:%M:%S") + """</li>
            <li>Python Version: """ + sys.version.split()[0] + """</li>
        </ul>

        <div class="info">
            <p><strong>üìù Note:</strong> This is a complete export of Python documentation using pydocs.</p>
        </div>
    </div>
</body>
</html>
"""
        return html_content

    def _create_index(self, modules: List[str], results: Dict):
        """Cr√©e un index g√©n√©ral."""
        index_content = """
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                  INDEX G√âN√âRAL - DOCUMENTATION PYTHON                        ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

Date d'export: """ + datetime.now().strftime("%d-%m-%Y %H:%M:%S") + """
Version Python: """ + sys.version.split()[0] + """
R√©pertoire de base: """ + str(self.output_base) + """

STRUCTURE DES DOSSIERS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìÅ TXT/
   ‚îî‚îÄ Chapters/: Chaque module en fichier TXT s√©par√©

üìÅ PDF/
   ‚îú‚îÄ A0/: Format papier A0
   ‚îú‚îÄ A1/: Format papier A1
   ‚îú‚îÄ A2/: Format papier A2
   ‚îú‚îÄ A3/: Format papier A3
   ‚îú‚îÄ A4/: Format papier A4 (standard)
   ‚îú‚îÄ A5/: Format papier A5
   ‚îî‚îÄ ...et autres formats

üìÅ EBOOK_EPUB/: Format livre √©lectronique EPUB

üìÅ EBOOK_MOBI/: Format livre √©lectronique MOBI (Kindle)

üìÅ HTML/: Pages HTML avec index interactif

LISTE DES MODULES DOCUMENT√âS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

"""
        for i, module_name in enumerate(modules, 1):
            index_content += f"{i:3d}. {module_name}\n"

        index_content += f"""

STATISTIQUES D'EXPORT
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Nombre total de modules: {len(modules)}
Timestamp: {results['timestamp']}

Formats export√©s:
"""
        for fmt, stats in results["formats"].items():
            index_content += f"\n‚úì {fmt.upper()}: {stats}\n"

        if results["errors"]:
            index_content += f"\n‚ö† Erreurs rencontr√©es: {len(results['errors'])}\n"
            for error in results["errors"]:
                index_content += f"  - {error}\n"

        # Sauvegarder l'index
        index_path = self.output_base / "INDEX.txt"
        with open(index_path, "w", encoding="utf-8") as f:
            f.write(index_content)

        print(f"[INDEX] Fichier d'index cr√©√©: {index_path}")

    def _export_xml(self, modules: List[str]) -> Dict:
        """Exports documentation in XML format."""
        stats = {
            "format": "XML",
            "files_created": 0,
            "total_size": 0,
            "chapters": [],
        }

        try:
            print(f"[XML] Exporting {len(modules)} modules...")

            for i, module_name in enumerate(modules, 1):
                try:
                    doc = self._get_module_doc_silent(module_name, renderer=pydoc.TextDoc())
                    xml_content = \
                        self.xml_formatter.format_module_doc(
                            module_name, doc)

                    filename = f"{module_name.replace('.', '_')}.xml"
                    filepath = self.xml_dir / filename

                    with open(filepath, "w", encoding="utf-8") as f:
                        f.write(xml_content)

                    file_size = filepath.stat().st_size
                    stats["files_created"] += 1
                    stats["total_size"] += file_size
                    stats["chapters"].append({
                        "name": module_name,
                        "file": filename,
                        "size": file_size,
                    })

                    if i % 5 == 0 or i == len(modules):
                        progress = self._format_progress(
                            i, len(modules))
                        print(f"  [XML] {progress}")

                except Exception as e:
                    msg = f"  [WARNING] Cannot export {module_name}: {e}"
                    print(msg)

            print(f"[XML] {stats['files_created']} files created")
        except Exception as e:
            print(f"[ERROR] XML export failed: {e}")

        return stats

    def _export_json(self, modules: List[str]) -> Dict:
        """Exports documentation in JSON format."""
        stats = {
            "format": "JSON",
            "files_created": 0,
            "total_size": 0,
            "chapters": [],
        }

        try:
            print(f"[JSON] Exporting {len(modules)} modules...")

            for i, module_name in enumerate(modules, 1):
                try:
                    doc = self._get_module_doc_silent(module_name, renderer=pydoc.TextDoc())
                    json_content = \
                        self.json_formatter.format_module_doc(
                            module_name, doc)

                    filename = f"{module_name.replace('.', '_')}.json"
                    filepath = self.json_dir / filename

                    with open(filepath, "w", encoding="utf-8") as f:
                        f.write(json_content)

                    file_size = filepath.stat().st_size
                    stats["files_created"] += 1
                    stats["total_size"] += file_size
                    stats["chapters"].append({
                        "name": module_name,
                        "file": filename,
                        "size": file_size,
                    })

                    if i % 5 == 0 or i == len(modules):
                        progress = self._format_progress(
                            i, len(modules))
                        print(f"  [JSON] {progress}")

                except Exception as e:
                    msg = f"  [WARNING] Cannot export {module_name}: {e}"
                    print(msg)

            print(f"[JSON] {stats['files_created']} files created")
        except Exception as e:
            print(f"[ERROR] JSON export failed: {e}")

        return stats

    def _export_csv(self, modules: List[str]) -> Dict:
        """Exports documentation in CSV format."""
        stats = {
            "format": "CSV",
            "files_created": 0,
            "total_size": 0,
            "chapters": [],
        }

        try:
            print(f"[CSV] Exporting {len(modules)} modules...")

            # Create master CSV with modules list
            master_csv = self.csv_formatter.format_index(
                modules, {"total": len(modules)})
            master_path = self.csv_dir / "INDEX.csv"
            with open(master_path, "w", encoding="utf-8") as f:
                f.write(master_csv)
            stats["files_created"] += 1
            stats["total_size"] += master_path.stat().st_size

            # Create individual module CSV files
            for i, module_name in enumerate(modules, 1):
                try:
                    doc = self._get_module_doc_silent(module_name, renderer=pydoc.TextDoc())
                    csv_content = \
                        self.csv_formatter.format_module_doc(
                            module_name, doc)

                    filename = f"{module_name.replace('.', '_')}.csv"
                    filepath = self.csv_dir / filename

                    with open(filepath, "w", encoding="utf-8") as f:
                        f.write(csv_content)

                    file_size = filepath.stat().st_size
                    stats["files_created"] += 1
                    stats["total_size"] += file_size
                    stats["chapters"].append({
                        "name": module_name,
                        "file": filename,
                        "size": file_size,
                    })

                    if i % 5 == 0 or i == len(modules):
                        progress = self._format_progress(
                            i, len(modules))
                        print(f"  [CSV] {progress}")

                except Exception as e:
                    msg = f"  [WARNING] Cannot export {module_name}: {e}"
                    print(msg)

            print(f"[CSV] {stats['files_created']} files created")
        except Exception as e:
            print(f"[ERROR] CSV export failed: {e}")

        return stats

    def _export_hlp(self, modules: List[str]) -> Dict:
        """Exports documentation in HLP format."""
        stats = {
            "format": "HLP",
            "files_created": 0,
            "total_size": 0,
            "chapters": [],
        }

        try:
            print(f"[HLP] Exporting {len(modules)} modules...")

            for i, module_name in enumerate(modules, 1):
                try:
                    doc = self._get_module_doc_silent(module_name, renderer=pydoc.TextDoc())
                    hlp_content = \
                        self.hlp_formatter.format_module_doc(
                            module_name, doc)

                    filename = f"{module_name.replace('.', '_')}.hlp"
                    filepath = self.hlp_dir / filename

                    with open(filepath, "w", encoding="utf-8") as f:
                        f.write(hlp_content)

                    file_size = filepath.stat().st_size
                    stats["files_created"] += 1
                    stats["total_size"] += file_size
                    stats["chapters"].append({
                        "name": module_name,
                        "file": filename,
                        "size": file_size,
                    })

                    if i % 5 == 0 or i == len(modules):
                        progress = self._format_progress(
                            i, len(modules))
                        print(f"  [HLP] {progress}")

                except Exception as e:
                    msg = f"  [WARNING] Cannot export {module_name}: {e}"
                    print(msg)

            print(f"[HLP] {stats['files_created']} files created")
        except Exception as e:
            print(f"[ERROR] HLP export failed: {e}")

        return stats

    def _export_md(self, modules: List[str]) -> Dict:
        """Exports documentation in Markdown format."""
        stats = {
            "format": "MARKDOWN",
            "files_created": 0,
            "total_size": 0,
            "chapters": [],
        }

        try:
            print(f"[MARKDOWN] Exporting {len(modules)} modules...")

            for i, module_name in enumerate(modules, 1):
                try:
                    doc = self._get_module_doc_silent(module_name, renderer=pydoc.TextDoc())
                    md_content = \
                        self.md_formatter.format_module_doc(
                            module_name, doc)

                    filename = f"{module_name.replace('.', '_')}.md"
                    filepath = self.md_dir / filename

                    with open(filepath, "w", encoding="utf-8") as f:
                        f.write(md_content)

                    file_size = filepath.stat().st_size
                    stats["files_created"] += 1
                    stats["total_size"] += file_size
                    stats["chapters"].append({
                        "name": module_name,
                        "file": filename,
                        "size": file_size,
                    })

                    if i % 5 == 0 or i == len(modules):
                        progress = self._format_progress(
                            i, len(modules))
                        print(f"  [MARKDOWN] {progress}")

                except Exception as e:
                    msg = f"  [WARNING] Cannot export {module_name}: {e}"
                    print(msg)

            print(f"[MARKDOWN] {stats['files_created']} files created")
        except Exception as e:
            print(f"[ERROR] MARKDOWN export failed: {e}")

        return stats

    def _export_rst(self, modules: List[str]) -> Dict:
        """Exports documentation in reStructuredText format."""
        stats = {
            "format": "RST",
            "files_created": 0,
            "total_size": 0,
            "chapters": [],
        }

        try:
            print(f"[RST] Exporting {len(modules)} modules...")

            for i, module_name in enumerate(modules, 1):
                try:
                    doc = self._get_module_doc_silent(module_name, renderer=pydoc.TextDoc())
                    rst_content = \
                        self.rst_formatter.format_module_doc(
                            module_name, doc)

                    filename = f"{module_name.replace('.', '_')}.rst"
                    filepath = self.rst_dir / filename

                    with open(filepath, "w", encoding="utf-8") as f:
                        f.write(rst_content)

                    file_size = filepath.stat().st_size
                    stats["files_created"] += 1
                    stats["total_size"] += file_size
                    stats["chapters"].append({
                        "name": module_name,
                        "file": filename,
                        "size": file_size,
                    })

                    if i % 5 == 0 or i == len(modules):
                        progress = self._format_progress(
                            i, len(modules))
                        print(f"  [RST] {progress}")

                except Exception as e:
                    msg = f"  [WARNING] Cannot export {module_name}: {e}"
                    print(msg)

            print(f"[RST] {stats['files_created']} files created")
        except Exception as e:
            print(f"[ERROR] RST export failed: {e}")

        return stats

    def _export_azw(self, modules: List[str]) -> Dict:
        """Exports documentation in AZW (Kindle) format."""
        stats = {
            "format": "AZW",
            "files_created": 0,
            "total_size": 0,
            "chapters": [],
        }

        try:
            print(f"[AZW] Exporting {len(modules)} modules...")

            for i, module_name in enumerate(modules, 1):
                try:
                    doc = self._get_module_doc_silent(module_name, renderer=pydoc.TextDoc())
                    azw_content = \
                        self.azw_formatter.format_module_doc(
                            module_name, doc)

                    filename = f"{module_name.replace('.', '_')}.azw"
                    filepath = self.azw_dir / filename

                    with open(filepath, "w", encoding="utf-8") as f:
                        f.write(azw_content)

                    file_size = filepath.stat().st_size
                    stats["files_created"] += 1
                    stats["total_size"] += file_size
                    stats["chapters"].append({
                        "name": module_name,
                        "file": filename,
                        "size": file_size,
                    })

                    if i % 5 == 0 or i == len(modules):
                        progress = self._format_progress(
                            i, len(modules))
                        print(f"  [AZW] {progress}")

                except Exception as e:
                    msg = f"  [WARNING] Cannot export {module_name}: {e}"
                    print(msg)

            print(f"[AZW] {stats['files_created']} files created")
        except Exception as e:
            print(f"[ERROR] AZW export failed: {e}")

        return stats

    def _export_docx(self, modules: List[str]) -> Dict:
        """Exports documentation in DOCX format."""
        stats = {
            "format": "DOCX",
            "files_created": 0,
            "total_size": 0,
            "chapters": [],
        }

        try:
            print(f"[DOCX] Exporting {len(modules)} modules...")

            for i, module_name in enumerate(modules, 1):
                try:
                    doc = self._get_module_doc_silent(module_name, renderer=pydoc.TextDoc())
                    docx_content = \
                        self.docx_formatter.format_module_doc(
                            module_name, doc)

                    filename = f"{module_name.replace('.', '_')}.docx"
                    filepath = self.docx_dir / filename

                    with open(filepath, "w", encoding="utf-8") as f:
                        f.write(docx_content)

                    file_size = filepath.stat().st_size
                    stats["files_created"] += 1
                    stats["total_size"] += file_size
                    stats["chapters"].append({
                        "name": module_name,
                        "file": filename,
                        "size": file_size,
                    })

                    if i % 5 == 0 or i == len(modules):
                        progress = self._format_progress(
                            i, len(modules))
                        print(f"  [DOCX] {progress}")

                except Exception as e:
                    msg = f"  [WARNING] Cannot export {module_name}: {e}"
                    print(msg)

            print(f"[DOCX] {stats['files_created']} files created")
        except Exception as e:
            print(f"[ERROR] DOCX export failed: {e}")

        return stats

    def _export_yaml(self, modules: List[str]) -> Dict:
        """Exports documentation in YAML format."""
        stats = {
            "format": "YAML",
            "files_created": 0,
            "total_size": 0,
            "chapters": [],
        }

        try:
            print(f"[YAML] Exporting {len(modules)} modules...")

            for i, module_name in enumerate(modules, 1):
                try:
                    doc = self._get_module_doc_silent(module_name, renderer=pydoc.TextDoc())
                    yaml_content = \
                        self.yaml_formatter.format_module_doc(
                            module_name, doc)

                    filename = f"{module_name.replace('.', '_')}.yaml"
                    filepath = self.yaml_dir / filename

                    with open(filepath, "w", encoding="utf-8") as f:
                        f.write(yaml_content)

                    file_size = filepath.stat().st_size
                    stats["files_created"] += 1
                    stats["total_size"] += file_size
                    stats["chapters"].append({
                        "name": module_name,
                        "file": filename,
                        "size": file_size,
                    })

                    if i % 5 == 0 or i == len(modules):
                        progress = self._format_progress(
                            i, len(modules))
                        print(f"  [YAML] {progress}")

                except Exception as e:
                    msg = f"  [WARNING] Cannot export {module_name}: {e}"
                    print(msg)

            print(f"[YAML] {stats['files_created']} files created")
        except Exception as e:
            print(f"[ERROR] YAML export failed: {e}")

        return stats

    def _export_sqlite(self, modules: List[str]) -> Dict:
        """Exports documentation in SQLite database format."""
        stats = {
            "format": "SQLITE",
            "files_created": 0,
            "total_size": 0,
            "chapters": [],
        }

        try:
            print(f"[SQLITE] Exporting {len(modules)} modules...")

            # Create SQL schema file
            schema_content = \
                self.sqlite_formatter.format_index(modules, {})
            schema_path = self.sqlite_dir / "schema.sql"
            with open(schema_path, "w", encoding="utf-8") as f:
                f.write(schema_content)
            stats["files_created"] += 1
            stats["total_size"] += schema_path.stat().st_size

            # Create individual SQL files per module
            for i, module_name in enumerate(modules, 1):
                try:
                    doc = self._get_module_doc_silent(module_name, renderer=pydoc.TextDoc())
                    sql_content = \
                        self.sqlite_formatter.format_module_doc(
                            module_name, doc)

                    filename = f"{module_name.replace('.', '_')}.sql"
                    filepath = self.sqlite_dir / filename

                    with open(filepath, "w", encoding="utf-8") as f:
                        f.write(sql_content)

                    file_size = filepath.stat().st_size
                    stats["files_created"] += 1
                    stats["total_size"] += file_size
                    stats["chapters"].append({
                        "name": module_name,
                        "file": filename,
                        "size": file_size,
                    })

                    if i % 5 == 0 or i == len(modules):
                        progress = self._format_progress(
                            i, len(modules))
                        print(f"  [SQLITE] {progress}")

                except Exception as e:
                    msg = f"  [WARNING] Cannot export {module_name}: {e}"
                    print(msg)

            print(f"[SQLITE] {stats['files_created']} files created")
        except Exception as e:
            print(f"[ERROR] SQLITE export failed: {e}")

        return stats

    def _save_log(self, results: Dict):


        """Sauvegarde le log d'export."""
        log_path = self.output_base / f"export_log_{self.timestamp}.json"
        try:
            with open(log_path, "w", encoding="utf-8") as f:
                json.dump(results, f, indent=2, ensure_ascii=False)
            print(f"[LOG] Fichier de log cr√©√©: {log_path}")
        except Exception as e:
            print(f"[ERREUR LOG] {e}")
