# Generated by AI - Python Module

"""
Formatting Module - Formatters for different output types
==========================================================

Provides formatting classes for TXT, PDF, EPUB, RTF, etc.
"""

from datetime import datetime
from pathlib import Path
from typing import Optional, List
import textwrap


class BaseFormatter:
    """Base class for all formatters."""

    def __init__(self, max_width: int = 80):
        self.max_width = max_width
        self.content = []

    def add_title(self, title: str, level: int = 1):
        """Adds a title."""
        if level == 1:
            self.content.append("=" * len(title))
            self.content.append(title)
            self.content.append("=" * len(title))
        elif level == 2:
            self.content.append("-" * len(title))
            self.content.append(title)
            self.content.append("-" * len(title))
        else:
            self.content.append(f"{'  ' * (level - 1)}{title}")

    def add_paragraph(self, text: str):
        """Adds a paragraph."""
        wrapped = textwrap.fill(text, width=self.max_width)
        self.content.append(wrapped)

    def add_code(self, code: str, language: str = ""):
        """Adds a code block."""
        self.content.append("")
        self.content.append("```" + language)
        self.content.append(code)
        self.content.append("```")
        self.content.append("")

    def get_content(self) -> str:
        """Returns formatted content."""
        return "\n".join(self.content)


class TextFormatter(BaseFormatter):
    """Formatter for text files."""

    def __init__(self):
        super().__init__(max_width=80)

    def format_module_doc(self, module_name: str, doc_text: str) -> str:
        """Formats module documentation."""
        self.content = []
        self.add_title(f"MODULE: {module_name}", 1)
        self.content.append(f"Export Date: {datetime.now().isoformat()}\n")
        self.add_paragraph(doc_text)
        return self.get_content()

    def format_index(self, modules: List[str], stats: dict) -> str:
        """Formats a module index."""
        self.content = []
        self.add_title("DOCUMENTATION INDEX", 1)
        self.content.append(f"Generated: {datetime.now().isoformat()}")
        self.content.append(f"Total Modules: {len(modules)}")
        self.content.append("")

        self.add_title("MODULES", 2)
        for i, module in enumerate(modules, 1):
            self.content.append(f"{i:3d}. {module}")

        self.content.append("")
        self.add_title("STATISTICS", 2)
        for key, value in stats.items():
            self.content.append(f"  {key}: {value}")

        return self.get_content()


class PDFFormatter(BaseFormatter):
    """Formatter for PDF files."""

    def __init__(self):
        super().__init__(max_width=80)

    def format_for_paper_size(self, content: str, paper_size: str) -> str:
        """Adapts content for a specific paper format."""
        PAPER_MARGINS = {
            "A0": (50, 50),
            "A1": (40, 40),
            "A2": (35, 35),
            "A3": (30, 30),
            "A4": (25, 25),
            "A5": (20, 20),
            "A6": (15, 15),
            "A7": (10, 10),
            "A8": (10, 10),
            "A9": (8, 8),
            "A10": (5, 5),
        }

        margins = PAPER_MARGINS.get(paper_size, (25, 25))
        header = f"[PDF Format: {paper_size} | Margins: {margins[0]}mm | Generated: {datetime.now().isoformat()}]\n\n"

        return header + content

    def create_toc_page(self, chapters: List[str]) -> str:
        """Creates a table of contents page."""
        toc = ["=" * 80]
        toc.append("TABLE OF CONTENTS")
        toc.append("=" * 80)
        toc.append("")

        for i, chapter in enumerate(chapters, 1):
            toc.append(f"{i:3d}. {chapter}")

        toc.append("")
        return "\n".join(toc)


class EbookFormatter(BaseFormatter):
    """Formatter for e-books (EPUB, MOBI)."""

    def __init__(self):
        super().__init__(max_width=100)

    def format_epub_chapter(self, title: str, content: str) -> str:
        """Formats a chapter for EPUB."""
        epub_html = f"""<div class="chapter">
<h1>{title}</h1>
<p>{content}</p>
</div>
"""
        return epub_html

    def format_mobi_chapter(self, title: str, content: str) -> str:
        """Formats a chapter for MOBI."""
        mobi_format = f"""[CHAPTER]
{title}
{'-' * len(title)}

{content}

[END_CHAPTER]
"""
        return mobi_format

    def create_toc_xml(self, chapters: List[dict]) -> str:
        """Creates a table of contents in XML."""
        toc = """<?xml version="1.0" encoding="utf-8"?>
<ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1">
<head>
<meta name="dtb:uid" content="python-documentation"/>
<meta name="dtb:depth" content="2"/>
</head>
<docTitle>
<text>Python Documentation</text>
</docTitle>
<navMap>
"""
        for i, chapter in enumerate(chapters, 1):
            toc += f"""<navPoint id="navPoint-{i}" playOrder="{i}">
<navLabel><text>{chapter.get('title', f'Chapter {i}')}</text></navLabel>
<content src="{chapter.get('file', f'chapter_{i}.html')}"/>
</navPoint>
"""

        toc += """</navMap>
</ncx>
"""
        return toc

    def create_mimetype_file(self) -> str:
        """Returns the content of the mimetype file."""
        return "application/epub+zip"

    def create_container_xml(self) -> str:
        """Creates the container.xml file."""
        container = """<?xml version="1.0" encoding="UTF-8"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
<rootfiles>
<rootfile full-path="content.opf" media-type="application/oebps-package+xml"/>
</rootfiles>
</container>
"""
        return container

    def create_content_opf(self, title: str, chapters: List[dict]) -> str:
        """Creates the content.opf file."""
        opf = f"""<?xml version="1.0" encoding="utf-8"?>
<package xmlns="http://www.idpf.org/2007/opf" version="2.0" unique-identifier="uuid_id">
<metadata xmlns:dc="http://purl.org/dc/elements/1.1/">
<dc:title>{title}</dc:title>
<dc:creator>Python Documentation Export</dc:creator>
<dc:language>en</dc:language>
<dc:date>{datetime.now().isoformat()}</dc:date>
</metadata>
<manifest>
<item id="ncx" href="toc.ncx" media-type="application/x-dtbncx+xml"/>
"""
        for i, chapter in enumerate(chapters, 1):
            opf += f'<item id="chapter_{i}" href="{chapter.get("file", f"chapter_{i}.html")}" media-type="application/xhtml+xml"/>\n'

        opf += """</manifest>
<spine toc="ncx">
"""
        for i in range(1, len(chapters) + 1):
            opf += f'<itemref idref="chapter_{i}"/>\n'

        opf += """</spine>
</package>
"""
        return opf


class RTFFormatter(BaseFormatter):
    """Formatter for Rich Text Format (RTF) files."""

    def __init__(self):
        super().__init__(max_width=80)

    def _escape_rtf(self, text: str) -> str:
        """Escapes special characters for RTF."""
        text = text.replace("\\", "\\\\")
        text = text.replace("{", "\\{")
        text = text.replace("}", "\\}")
        return text

    def format_module_doc(self, module_name: str, doc_text: str) -> str:
        """Formats module documentation for RTF."""
        self.content = []
        self.content.append("{\\rtf1\\ansi\\ansicpg1252\\deff0\\deflang1033")
        self.content.append("{\\fonttbl{\\f0\\fnil\\fcharset0 Courier New;}}")
        self.content.append("{\\colortbl;\\red0\\green0\\blue0;}")
        self.content.append("\\viewkind4\\uc1\\pard\\f0\\fs20")
        
        # Title
        self.content.append("\\b MODULE: " + self._escape_rtf(module_name) + "\\b0\\par\\par")
        
        # Export date
        self.content.append("Export Date: " + self._escape_rtf(datetime.now().isoformat()) + "\\par\\par")
        
        # Content
        self.content.append(self._escape_rtf(doc_text) + "\\par")
        self.content.append("}")
        
        return "\n".join(self.content)

    def format_index(self, modules: List[str], stats: dict) -> str:
        """Formats a module index for RTF."""
        self.content = []
        self.content.append("{\\rtf1\\ansi\\ansicpg1252\\deff0\\deflang1033")
        self.content.append("{\\fonttbl{\\f0\\fnil\\fcharset0 Courier New;}}")
        self.content.append("{\\colortbl;\\red0\\green0\\blue0;}")
        self.content.append("\\viewkind4\\uc1\\pard\\f0\\fs20")
        
        # Title
        self.content.append("\\b\\fs28 DOCUMENTATION INDEX\\b0\\fs20\\par\\par")
        
        # Generated date
        self.content.append("Generated: " + self._escape_rtf(datetime.now().isoformat()) + "\\par")
        self.content.append("Total Modules: " + str(len(modules)) + "\\par\\par")
        
        # Modules section
        self.content.append("\\b MODULES\\b0\\par")
        for i, module in enumerate(modules, 1):
            self.content.append(str(i).rjust(3) + ". " + self._escape_rtf(module) + "\\par")
        
        self.content.append("\\par")
        
        # Statistics section
        self.content.append("\\b STATISTICS\\b0\\par")
        for key, value in stats.items():
            self.content.append("  " + self._escape_rtf(str(key)) + ": " + self._escape_rtf(str(value)) + "\\par")
        
        self.content.append("}")
        
        return "\n".join(self.content)


class XMLFormatter(BaseFormatter):
    """Formatter for XML files."""

    def __init__(self):
        super().__init__(max_width=80)

    def _escape_xml(self, text: str) -> str:
        """Escapes special characters for XML."""
        text = text.replace("&", "&amp;")
        text = text.replace("<", "&lt;")
        text = text.replace(">", "&gt;")
        text = text.replace("\"", "&quot;")
        text = text.replace("'", "&apos;")
        return text

    def format_module_doc(self, module_name: str, doc_text: str) -> str:
        """Formats module documentation for XML."""
        self.content = []
        self.content.append('<?xml version="1.0" encoding="UTF-8"?>')
        self.content.append("<documentation>")
        self.content.append(f"  <module>")
        self.content.append(f"    <name>{self._escape_xml(module_name)}</name>")
        self.content.append(f"    <export_date>{datetime.now().isoformat()}</export_date>")
        self.content.append(f"    <content>{self._escape_xml(doc_text)}</content>")
        self.content.append(f"  </module>")
        self.content.append("</documentation>")
        return "\n".join(self.content)

    def format_index(self, modules: List[str], stats: dict) -> str:
        """Formats a module index for XML."""
        self.content = []
        self.content.append('<?xml version="1.0" encoding="UTF-8"?>')
        self.content.append("<documentation>")
        self.content.append("  <index>")
        self.content.append(f"    <generated>{datetime.now().isoformat()}</generated>")
        self.content.append(f"    <total_modules>{len(modules)}</total_modules>")
        self.content.append("    <modules>")
        
        for i, module in enumerate(modules, 1):
            self.content.append(f"      <module id=\"{i}\">{self._escape_xml(module)}</module>")
        
        self.content.append("    </modules>")
        self.content.append("    <statistics>")
        for key, value in stats.items():
            self.content.append(f"      <stat name=\"{self._escape_xml(str(key))}\">{self._escape_xml(str(value))}</stat>")
        self.content.append("    </statistics>")
        self.content.append("  </index>")
        self.content.append("</documentation>")
        return "\n".join(self.content)


class JSONFormatter(BaseFormatter):
    """Formatter for JSON files."""

    def __init__(self):
        super().__init__(max_width=80)

    def format_module_doc(self, module_name: str, doc_text: str) -> str:
        """Formats module documentation for JSON."""
        import json
        data = {
            "module": module_name,
            "export_date": datetime.now().isoformat(),
            "content": doc_text
        }
        return json.dumps(data, indent=2, ensure_ascii=False)

    def format_index(self, modules: List[str], stats: dict) -> str:
        """Formats a module index for JSON."""
        import json
        data = {
            "generated": datetime.now().isoformat(),
            "total_modules": len(modules),
            "modules": modules,
            "statistics": stats
        }
        return json.dumps(data, indent=2, ensure_ascii=False)


class CSVFormatter(BaseFormatter):
    """Formatter for CSV files."""

    def __init__(self):
        super().__init__(max_width=80)

    def _escape_csv(self, text: str) -> str:
        """Escapes special characters for CSV."""
        if "," in text or "\"" in text or "\n" in text:
            text = text.replace("\"", "\"\"")
            return f'"{text}"'
        return text

    def format_module_doc(self, module_name: str, doc_text: str) -> str:
        """Formats module documentation for CSV."""
        # For single module, return as simple CSV
        lines = doc_text.split("\n")
        csv_content = []
        csv_content.append(f"field,value")
        csv_content.append(f"module_name,{self._escape_csv(module_name)}")
        csv_content.append(f"export_date,{datetime.now().isoformat()}")
        
        for i, line in enumerate(lines[:50]):  # Limit lines
            csv_content.append(f"content_line_{i},{self._escape_csv(line)}")
        
        return "\n".join(csv_content)

    def format_index(self, modules: List[str], stats: dict) -> str:
        """Formats a module index for CSV."""
        csv_content = []
        csv_content.append("id,module_name")
        
        for i, module in enumerate(modules, 1):
            csv_content.append(f"{i},{self._escape_csv(module)}")
        
        return "\n".join(csv_content)


class HLPFormatter(BaseFormatter):
    """Formatter for Windows HLP (Help) files (text representation)."""

    def __init__(self):
        super().__init__(max_width=80)

    def _format_help_file(self, title: str, content: str) -> str:
        """Formats content as Windows HLP text."""
        lines = []
        lines.append(r"{\rtf1\ansi\ansicpg1252\deff0")
        lines.append(r"{\fonttbl{\f0\fnil\fcharset0 Arial;}}")
        lines.append(r"{\*\generator Msftedit 5.41.21.2510;}")
        lines.append(r"\viewkind4\uc1\pard\f0\fs20")
        lines.append(f"\\b {title}\\b0\\par\\par")
        lines.append(f"Date: {datetime.now().isoformat()}\\par\\par")
        lines.append(content.replace("\n", "\\par\n"))
        lines.append("}")
        return "\n".join(lines)

    def format_module_doc(self, module_name: str, doc_text: str) -> str:
        """Formats module documentation for HLP."""
        return self._format_help_file(f"MODULE: {module_name}", doc_text)

    def format_index(self, modules: List[str], stats: dict) -> str:
        """Formats a module index for HLP."""
        lines = []
        lines.append("MODULES\\par")
        for i, module in enumerate(modules, 1):
            lines.append(f"{i}. {module}\\par")
        
        lines.append("\\par STATISTICS\\par")
        for key, value in stats.items():
            lines.append(f"{key}: {value}\\par")
        
        return self._format_help_file("DOCUMENTATION INDEX", "\n".join(lines))


class MDFormatter(BaseFormatter):
    """Formatter for Markdown files."""

    def __init__(self):
        super().__init__(max_width=80)

    def format_module_doc(self, module_name: str, doc_text: str) -> str:
        """Formats module documentation for Markdown."""
        lines = []
        lines.append(f"# {module_name}\n")
        lines.append(f"**Export Date:** {datetime.now().isoformat()}\n")
        lines.append("---\n")
        lines.append("## Documentation\n")
        
        # Convert to markdown-friendly format
        doc_lines = doc_text.split("\n")
        for line in doc_lines:
            if line.strip():
                lines.append(line)
        
        return "\n".join(lines)

    def format_index(self, modules: List[str], stats: dict) -> str:
        """Formats a module index for Markdown."""
        lines = []
        lines.append("# Python Documentation Index\n")
        lines.append(f"**Generated:** {datetime.now().isoformat()}\n")
        lines.append(f"**Total Modules:** {len(modules)}\n\n")
        
        lines.append("## Modules\n")
        for i, module in enumerate(modules, 1):
            lines.append(f"{i}. `{module}`")
        
        lines.append("\n## Statistics\n")
        for key, value in stats.items():
            lines.append(f"- **{key}:** {value}")
        
        return "\n".join(lines)


class RSTFormatter(BaseFormatter):
    """Formatter for reStructuredText files (Sphinx compatible)."""

    def __init__(self):
        super().__init__(max_width=80)

    def format_module_doc(self, module_name: str, doc_text: str) -> str:
        """Formats module documentation for reStructuredText."""
        lines = []
        lines.append(module_name)
        lines.append("=" * len(module_name))
        lines.append("")
        lines.append(f":Export Date: {datetime.now().isoformat()}")
        lines.append("")
        lines.append("Documentation")
        lines.append("-" * 13)
        lines.append("")
        
        doc_lines = doc_text.split("\n")
        for line in doc_lines:
            if line.strip():
                lines.append(line)
        
        return "\n".join(lines)

    def format_index(self, modules: List[str], stats: dict) -> str:
        """Formats a module index for reStructuredText."""
        lines = []
        lines.append("Python Documentation Index")
        lines.append("=" * 26)
        lines.append("")
        lines.append(f":Generated: {datetime.now().isoformat()}")
        lines.append(f":Total Modules: {len(modules)}")
        lines.append("")
        
        lines.append("Modules")
        lines.append("-" * 7)
        lines.append("")
        
        for i, module in enumerate(modules, 1):
            lines.append(f"{i}. ``{module}``")
        
        lines.append("")
        lines.append("Statistics")
        lines.append("-" * 10)
        lines.append("")
        
        for key, value in stats.items():
            lines.append(f":{key}: {value}")
        
        return "\n".join(lines)


class AZWFormatter(BaseFormatter):
    """Formatter for AZW (Amazon Kindle) format.
    
    Note: AZW is binary format. This creates a KF8-compatible
    structure that can be converted to AZW.
    """

    def __init__(self):
        super().__init__(max_width=80)

    def _create_mobi_header(self, title: str) -> str:
        """Creates MOBI-compatible header for AZW."""
        return (
            r"{\rtf1\ansi\ansicpg1252\deff0"
            r"{\fonttbl{\f0\fnil\fcharset0 Arial;}}"
            f"\\b {title}\\b0\\par\\par"
            f"Date: {datetime.now().isoformat()}\\par\\par"
        )

    def format_module_doc(self, module_name: str, doc_text: str) -> str:
        """Formats module documentation for AZW."""
        lines = []
        lines.append(self._create_mobi_header(f"MODULE: {module_name}"))
        lines.append(doc_text.replace("\n", "\\par\n"))
        lines.append("}")
        return "\n".join(lines)

    def format_index(self, modules: List[str], stats: dict) -> str:
        """Formats a module index for AZW."""
        lines = []
        lines.append(self._create_mobi_header("DOCUMENTATION INDEX"))
        
        lines.append("MODULES\\par")
        for i, module in enumerate(modules, 1):
            lines.append(f"{i}. {module}\\par")
        
        lines.append("\\par")
        lines.append("STATISTICS\\par")
        for key, value in stats.items():
            lines.append(f"{key}: {value}\par")
        
        lines.append("}")
        return "\n".join(lines)


class DOCXFormatter(BaseFormatter):
    """Formatter for DOCX (Microsoft Word) format.
    
    Note: DOCX is XML-based. This creates XML structure
    that can be packaged as .docx.
    """

    def __init__(self):
        super().__init__(max_width=80)

    def _escape_xml(self, text: str) -> str:
        """Escapes XML special characters."""
        text = text.replace("&", "&amp;")
        text = text.replace("<", "&lt;")
        text = text.replace(">", "&gt;")
        return text

    def format_module_doc(self, module_name: str, doc_text: str) -> str:
        """Formats module documentation for DOCX."""
        lines = []
        lines.append('<?xml version="1.0" encoding="UTF-8"?>')
        lines.append("<document>")
        lines.append(f"  <heading level=\"1\">{self._escape_xml(module_name)}"
                     "</heading>")
        lines.append(f"  <paragraph>Export: {datetime.now().isoformat()}"
                     "</paragraph>")
        
        doc_lines = doc_text.split("\n")
        for line in doc_lines:
            if line.strip():
                lines.append(
                    f"  <paragraph>{self._escape_xml(line)}</paragraph>"
                )
        
        lines.append("</document>")
        return "\n".join(lines)

    def format_index(self, modules: List[str], stats: dict) -> str:
        """Formats a module index for DOCX."""
        lines = []
        lines.append('<?xml version="1.0" encoding="UTF-8"?>')
        lines.append("<document>")
        lines.append("  <heading level=\"1\">Documentation Index</heading>")
        lines.append(f"  <paragraph>Generated: {datetime.now().isoformat()}"
                     "</paragraph>")
        lines.append(f"  <paragraph>Total Modules: {len(modules)}</paragraph>")
        lines.append("")
        
        lines.append("  <heading level=\"2\">Modules</heading>")
        for i, module in enumerate(modules, 1):
            lines.append(f"  <paragraph>{i}. {self._escape_xml(module)}"
                        "</paragraph>")
        
        lines.append("")
        lines.append("  <heading level=\"2\">Statistics</heading>")
        for key, value in stats.items():
            lines.append(f"  <paragraph>{self._escape_xml(str(key))}: "
                        f"{self._escape_xml(str(value))}</paragraph>")
        
        lines.append("</document>")
        return "\n".join(lines)


class YAMLFormatter(BaseFormatter):
    """Formatter for YAML format."""

    def __init__(self):
        super().__init__(max_width=80)

    def format_module_doc(self, module_name: str, doc_text: str) -> str:
        """Formats module documentation for YAML."""
        lines = []
        lines.append("---")
        lines.append(f"module: {module_name}")
        lines.append(f"export_date: {datetime.now().isoformat()}")
        lines.append("documentation: |")
        
        doc_lines = doc_text.split("\n")
        for line in doc_lines:
            lines.append(f"  {line}")
        
        return "\n".join(lines)

    def format_index(self, modules: List[str], stats: dict) -> str:
        """Formats a module index for YAML."""
        lines = []
        lines.append("---")
        lines.append(f"generated: {datetime.now().isoformat()}")
        lines.append(f"total_modules: {len(modules)}")
        lines.append("modules:")
        
        for module in modules:
            lines.append(f"  - {module}")
        
        lines.append("statistics:")
        for key, value in stats.items():
            lines.append(f"  {key}: {value}")
        
        return "\n".join(lines)


class SQLiteFormatter(BaseFormatter):
    """Formatter for SQLite database format.
    
    Note: Creates SQL statements to populate SQLite database.
    """

    def __init__(self):
        super().__init__(max_width=80)

    def _escape_sql(self, text: str) -> str:
        """Escapes SQL special characters."""
        return text.replace("'", "''")

    def format_module_doc(self, module_name: str, doc_text: str) -> str:
        """Formats module documentation for SQLite."""
        escaped_module = self._escape_sql(module_name)
        escaped_doc = self._escape_sql(doc_text)
        
        lines = []
        lines.append("CREATE TABLE IF NOT EXISTS modules (")
        lines.append("  id INTEGER PRIMARY KEY,")
        lines.append("  name TEXT NOT NULL,")
        lines.append("  export_date TEXT,")
        lines.append("  documentation TEXT")
        lines.append(");")
        lines.append("")
        lines.append("INSERT INTO modules (name, export_date, "
                    "documentation)")
        lines.append("VALUES (")
        lines.append(f"  '{escaped_module}',")
        lines.append(f"  '{datetime.now().isoformat()}',")
        lines.append(f"  '{escaped_doc}'")
        lines.append(");")
        
        return "\n".join(lines)

    def format_index(self, modules: List[str], stats: dict) -> str:
        """Formats a module index for SQLite."""
        lines = []
        lines.append("CREATE TABLE IF NOT EXISTS module_index (")
        lines.append("  id INTEGER PRIMARY KEY,")
        lines.append("  module_name TEXT NOT NULL UNIQUE")
        lines.append(");")
        lines.append("")
        lines.append("CREATE TABLE IF NOT EXISTS export_stats (")
        lines.append("  key TEXT PRIMARY KEY,")
        lines.append("  value TEXT")
        lines.append(");")
        lines.append("")
        
        for i, module in enumerate(modules, 1):
            escaped = self._escape_sql(module)
            lines.append(f"INSERT INTO module_index VALUES ({i}, "
                        f"'{escaped}');")
        
        lines.append("")
        for key, value in stats.items():
            escaped_key = self._escape_sql(str(key))
            escaped_val = self._escape_sql(str(value))
            lines.append(f"INSERT INTO export_stats VALUES "
                        f"('{escaped_key}', '{escaped_val}');")
        
        return "\n".join(lines)
