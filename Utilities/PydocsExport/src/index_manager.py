# Generated by AI - Python Module

"""
Module de gestion des index
============================

GÃ¨re la crÃ©ation et la maintenance des index de documentation.
"""

from pathlib import Path
from typing import List, Dict, Optional
from datetime import datetime
import json


class IndexManager:
    """GÃ¨re les index de documentation."""

    def __init__(self):
        self.entries = []
        self.created_at = datetime.now()

    def add_entry(
        self,
        name: str,
        path: str,
        category: str,
        file_size: int,
        module_type: str = "built-in"
    ):
        """Ajoute une entrÃ©e Ã  l'index."""
        entry = {
            "name": name,
            "path": path,
            "category": category,
            "file_size": file_size,
            "module_type": module_type,
            "added_at": datetime.now().isoformat(),
        }
        self.entries.append(entry)

    def get_entries_by_category(self, category: str) -> List[Dict]:
        """Retourne les entrÃ©es d'une catÃ©gorie spÃ©cifique."""
        return [e for e in self.entries if e["category"] == category]

    def create_index_file(self, output_path: Path, format: str = "txt") -> Path:
        """CrÃ©e un fichier d'index."""
        if format == "txt":
            return self._create_txt_index(output_path)
        elif format == "json":
            return self._create_json_index(output_path)
        elif format == "html":
            return self._create_html_index(output_path)
        else:
            raise ValueError(f"Format d'index non supportÃ©: {format}")

    def _create_txt_index(self, output_path: Path) -> Path:
        """CrÃ©e un index en format texte."""
        index_path = output_path / "index.txt"

        with open(index_path, "w", encoding="utf-8") as f:
            f.write("â•”" + "â•" * 78 + "â•—\n")
            f.write("â•‘" + " DOCUMENTATION INDEX - TEXT FORMAT ".center(78) + "â•‘\n")
            f.write("â•š" + "â•" * 78 + "â•\n\n")

            f.write(f"Generated: {self.created_at.isoformat()}\n")
            f.write(f"Total Entries: {len(self.entries)}\n\n")

            # Grouper par catÃ©gorie
            categories = {}
            for entry in self.entries:
                cat = entry["category"]
                if cat not in categories:
                    categories[cat] = []
                categories[cat].append(entry)

            for category in sorted(categories.keys()):
                f.write(f"\n{'=' * 80}\n")
                f.write(f"CATEGORY: {category.upper()}\n")
                f.write(f"{'=' * 80}\n\n")

                for i, entry in enumerate(categories[category], 1):
                    f.write(f"{i:3d}. {entry['name']}\n")
                    f.write(f"     Path: {entry['path']}\n")
                    f.write(f"     Size: {entry['file_size']:,} bytes\n")
                    f.write(f"     Type: {entry['module_type']}\n\n")

        return index_path

    def _create_json_index(self, output_path: Path) -> Path:
        """CrÃ©e un index en format JSON."""
        index_path = output_path / "index.json"

        index_data = {
            "metadata": {
                "created": self.created_at.isoformat(),
                "total_entries": len(self.entries),
            },
            "entries": self.entries,
        }

        with open(index_path, "w", encoding="utf-8") as f:
            json.dump(index_data, f, indent=2, ensure_ascii=False)

        return index_path

    def _create_html_index(self, output_path: Path) -> Path:
        """CrÃ©e un index en format HTML."""
        index_path = output_path / "index.html"

        html = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentation Index</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #333;
            border-bottom: 3px solid #0066cc;
            padding-bottom: 10px;
        }
        h2 {
            color: #0066cc;
            margin-top: 30px;
        }
        .entry {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #0066cc;
            border-radius: 4px;
        }
        .entry-name {
            font-weight: bold;
            color: #333;
        }
        .entry-meta {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }
        .stats {
            background: white;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>ðŸ“š Documentation Index</h1>
"""
        html += f"    <p>Generated: {self.created_at.isoformat()}</p>\n"
        html += f"    <p>Total Entries: {len(self.entries)}</p>\n"

        # Grouper par catÃ©gorie
        categories = {}
        for entry in self.entries:
            cat = entry["category"]
            if cat not in categories:
                categories[cat] = []
            categories[cat].append(entry)

        for category in sorted(categories.keys()):
            html += f"    <h2>{category.upper()}</h2>\n"
            for entry in categories[category]:
                html += f"""    <div class="entry">
        <div class="entry-name">{entry['name']}</div>
        <div class="entry-meta">
            <strong>Path:</strong> {entry['path']}<br>
            <strong>Size:</strong> {entry['file_size']:,} bytes<br>
            <strong>Type:</strong> {entry['module_type']}
        </div>
    </div>
"""

        html += """</body>
</html>
"""

        with open(index_path, "w", encoding="utf-8") as f:
            f.write(html)

        return index_path

    def export_to_dict(self) -> Dict:
        """Exporte l'index sous forme de dictionnaire."""
        return {
            "metadata": {
                "created": self.created_at.isoformat(),
                "total_entries": len(self.entries),
            },
            "entries": self.entries,
        }
