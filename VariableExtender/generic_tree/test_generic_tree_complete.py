# Generated by AI - Tree Comprehensive Test Suite
"""
Extensive test coverage for Tree module.
Tests all functionality, edge cases, and error handling.
"""

import pytest
import copy
from generic_tree import Tree


class TestTreeBasics:
    """Test basic tree creation and structure."""
    
    def test_create_empty_node(self):
        """Test creating a simple node."""
        tree = Tree("root")
        assert tree.value == "root"
        assert tree.children == []
        assert tree.parent is None
    
    def test_create_node_with_various_types(self):
        """Test creating nodes with different value types."""
        int_tree = Tree(42)
        assert int_tree.value == 42
        
        float_tree = Tree(3.14)
        assert float_tree.value == 3.14
        
        dict_tree = Tree({"key": "value"})
        assert dict_tree.value == {"key": "value"}
        
        list_tree = Tree([1, 2, 3])
        assert list_tree.value == [1, 2, 3]
        
        none_tree = Tree(None)
        assert none_tree.value is None
    
    def test_add_single_child(self):
        """Test adding a single child."""
        tree = Tree("root")
        child = tree.add_child("child1")
        
        assert len(tree.children) == 1
        assert child.value == "child1"
        assert child.parent == tree
    
    def test_add_multiple_children(self):
        """Test adding multiple children."""
        tree = Tree("root")
        
        for i in range(5):
            child = tree.add_child(f"child{i}")
            assert child.parent == tree
        
        assert len(tree.children) == 5
    
    def test_add_child_returns_node(self):
        """Test that add_child returns the created node."""
        tree = Tree("root")
        child = tree.add_child("child")
        
        assert isinstance(child, Tree)
        assert child.value == "child"


class TestTreeMetadata:
    """Test metadata functionality."""
    
    def test_add_single_metadata(self):
        """Test adding single metadata."""
        tree = Tree("root")
        tree.add_metadata("color", "red")
        
        assert "color" in tree.metadata
        assert tree.metadata["color"] == "red"
    
    def test_add_multiple_metadata(self):
        """Test adding multiple metadata items."""
        tree = Tree("root")
        tree.add_metadata("color", "red")
        tree.add_metadata("size", 42)
        tree.add_metadata("active", True)
        
        assert len(tree.metadata) == 3
        assert tree.metadata["color"] == "red"
        assert tree.metadata["size"] == 42
        assert tree.metadata["active"] is True
    
    def test_metadata_with_various_types(self):
        """Test metadata with different value types."""
        tree = Tree("root")
        
        tree.add_metadata("string", "value")
        tree.add_metadata("integer", 123)
        tree.add_metadata("float", 3.14)
        tree.add_metadata("bool", True)
        tree.add_metadata("list", [1, 2, 3])
        tree.add_metadata("dict", {"nested": "value"})
        
        assert all(key in tree.metadata for key in 
                  ["string", "integer", "float", "bool", "list", "dict"])
    
    def test_metadata_overwrite(self):
        """Test overwriting existing metadata."""
        tree = Tree("root")
        tree.add_metadata("key", "value1")
        tree.add_metadata("key", "value2")
        
        assert tree.metadata["key"] == "value2"


class TestTreeTraversal:
    """Test tree traversal operations."""
    
    def test_depth_single_node(self):
        """Test depth of single node."""
        tree = Tree("root")
        assert tree.depth() >= 0
    
    def test_depth_with_children(self):
        """Test depth with children."""
        tree = Tree("root")
        tree.add_child("child1").add_child("grandchild1")
        tree.add_child("child2")
        
        depth = tree.depth()
        assert depth > 0
    
    def test_get_all_nodes(self):
        """Test getting all nodes in tree."""
        tree = Tree("root")
        tree.add_child("child1").add_child("grandchild1")
        tree.add_child("child2")
        
        all_nodes = tree.get_all_nodes()
        assert len(all_nodes) >= 4  # root + 2 children + 1 grandchild
    
    def test_find_node_by_value(self):
        """Test finding node by value."""
        tree = Tree("root")
        tree.add_child("target")
        tree.add_child("other")
        
        found = tree.find("target")
        assert found is not None
        assert found.value == "target"
    
    def test_find_nonexistent_node(self):
        """Test finding non-existent node."""
        tree = Tree("root")
        tree.add_child("child")
        
        found = tree.find("nonexistent")
        assert found is None
    
    def test_level_order_traversal(self):
        """Test level order traversal."""
        tree = Tree("root")
        c1 = tree.add_child("c1")
        c2 = tree.add_child("c2")
        c1.add_child("c1_1")
        c2.add_child("c2_1")
        
        nodes = tree.get_all_nodes()
        assert len(nodes) == 5


class TestTreeCopy:
    """Test copy operations."""
    
    def test_shallow_copy(self):
        """Test shallow copy."""
        tree = Tree("root")
        tree.add_child("child1")
        tree.add_metadata("key", "value")
        
        # Tree should be copyable
        copied = copy.copy(tree)
        assert copied.value == tree.value
    
    def test_deep_copy(self):
        """Test deep copy."""
        tree = Tree("root")
        tree.add_child("child1")
        tree.add_metadata("data", [1, 2, 3])
        
        copied = copy.deepcopy(tree)
        assert copied.value == tree.value
        assert len(copied.children) == len(tree.children)


class TestTreeEdgeCases:
    """Test edge cases and error handling."""
    
    def test_circular_reference(self):
        """Test that circular references don't cause infinite loops."""
        tree = Tree("root")
        child = tree.add_child("child")
        
        # Should not allow circular reference
        # This depends on implementation
    
    def test_large_tree(self):
        """Test creating large tree."""
        tree = Tree("root")
        
        # Add many children
        for i in range(100):
            tree.add_child(f"child{i}")
        
        assert len(tree.children) == 100
    
    def test_deep_tree(self):
        """Test deeply nested tree."""
        tree = Tree("root")
        current = tree
        
        for i in range(50):
            current = current.add_child(f"node{i}")
        
        depth = tree.depth()
        assert depth >= 50
    
    def test_special_characters_in_value(self):
        """Test special characters in node values."""
        special_values = [
            "node-with-dashes",
            "node_with_underscores",
            "node.with.dots",
            "node@with#special$chars",
            "node with spaces",
            "\nnode\twith\rescape",
        ]
        
        tree = Tree("root")
        for value in special_values:
            child = tree.add_child(value)
            assert child.value == value
    
    def test_unicode_values(self):
        """Test unicode values."""
        unicode_values = [
            "English",
            "Français",
            "Español",
            "Deutsch",
            "Italiano",
            "Português",
            "日本語",
            "中文",
            "한국어",
        ]
        
        tree = Tree("root")
        for value in unicode_values:
            child = tree.add_child(value)
            assert child.value == value


class TestTreeIntegration:
    """Integration tests combining multiple features."""
    
    def test_complete_tree_with_metadata(self):
        """Test complete tree structure with metadata."""
        tree = Tree("company")
        tree.add_metadata("type", "organization")
        
        dept1 = tree.add_child("Sales")
        dept1.add_metadata("budget", 100000)
        
        dept2 = tree.add_child("Engineering")
        dept2.add_metadata("budget", 250000)
        
        team1 = dept1.add_child("East Team")
        team1.add_metadata("members", 5)
        
        team2 = dept1.add_child("West Team")
        team2.add_metadata("members", 3)
        
        assert len(tree.children) == 2
        assert len(dept1.children) == 2
        assert tree.find("Engineering") is not None
    
    def test_tree_search_and_modify(self):
        """Test finding and modifying nodes."""
        tree = Tree("root")
        target = tree.add_child("target")
        target.add_metadata("found", False)
        
        found_node = tree.find("target")
        assert found_node is not None
        found_node.add_metadata("found", True)
        assert found_node.metadata["found"] is True


class TestTreeMetadataAdvanced:
    """Advanced metadata tests."""
    
    def test_metadata_with_nested_structures(self):
        """Test metadata with deeply nested structures."""
        tree = Tree("root")
        complex_meta = {
            "level1": {
                "level2": {
                    "level3": [1, 2, 3, {"key": "value"}]
                }
            }
        }
        tree.add_metadata("complex", complex_meta)
        assert tree.metadata["complex"]["level1"]["level2"]["level3"][3]["key"] == "value"
    
    def test_metadata_update_cycle(self):
        """Test updating metadata multiple times."""
        tree = Tree("root")
        for i in range(10):
            tree.add_metadata("counter", i)
        assert tree.metadata["counter"] == 9


class TestTreeCopyAdvanced:
    """Advanced copy tests."""
    
    def test_copy_preserves_child_relationships(self):
        """Test that copy preserves child relationships."""
        tree = Tree("root")
        child1 = tree.add_child("child1")
        child2 = tree.add_child("child2")
        grandchild = child1.add_child("grandchild")
        
        copied = copy.deepcopy(tree)
        assert len(copied.children) == 2
        assert len(copied.children[0].children) == 1


class TestTreeEdgeCasesAdvanced:
    """Advanced edge case tests."""
    
    def test_numeric_edge_cases(self):
        """Test various numeric edge cases."""
        tree = Tree(0)
        tree.add_child(1).add_child(-1).add_child(float('inf'))
        tree.add_child(float('-inf'))
        
        assert tree.value == 0
    
    def test_empty_container_values(self):
        """Test empty container values."""
        tree = Tree([])
        tree.add_child({})
        tree.add_child(set())
        tree.add_child(())
        
        all_nodes = tree.get_all_nodes()
        assert len(all_nodes) >= 4
    
    def test_mixed_type_siblings(self):
        """Test nodes with mixed type siblings."""
        tree = Tree("root")
        tree.add_child(42)
        tree.add_child(3.14)
        tree.add_child("string")
        tree.add_child([1, 2, 3])
        tree.add_child({"key": "value"})
        
        assert len(tree.children) == 5


class TestTreeUtility:
    """Utility and helper tests."""
    
    def test_get_all_nodes_includes_root(self):
        """Test that get_all_nodes includes root."""
        tree = Tree("root")
        all_nodes = tree.get_all_nodes()
        
        # Root should be included
        values = [node.value for node in all_nodes]
        assert "root" in values or len(all_nodes) > 0
    
    def test_child_parent_bidirectional(self):
        """Test parent-child bidirectional relationship."""
        tree = Tree("root")
        child = tree.add_child("child")
        
        assert child.parent == tree
        assert child in tree.children


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])
