# Generated by AI - Python Module

"""
Utility functions for MultidimensionalPaint module.

This module contains helper functions for mathematical operations,
coordinate validation, and various utility operations.
"""

import math
from typing import Tuple, List, Union


def validate_coordinates(*coords) -> bool:
    """
    Validate that coordinates are numeric and consistent.
    
    Args:
        *coords: Variable number of coordinates
        
    Returns:
        bool: True if all coordinates are valid numbers
    """
    return all(isinstance(c, (int, float)) for c in coords)


def distance(point1: Tuple, point2: Tuple) -> float:
    """
    Calculate Euclidean distance between two points in n-dimensional space.
    
    Args:
        point1: First point coordinates
        point2: Second point coordinates
        
    Returns:
        float: Euclidean distance between the points
        
    Raises:
        ValueError: If points have different dimensions
    """
    if len(point1) != len(point2):
        raise ValueError(f"Points must have same dimensions: {len(point1)} != {len(point2)}")
    
    sum_of_squares = sum((p2 - p1) ** 2 for p1, p2 in zip(point1, point2))
    return math.sqrt(sum_of_squares)


def midpoint(*points: Tuple) -> Tuple:
    """
    Calculate midpoint of multiple points.

    Args:
        *points: Variable number of points

    Returns:
        Tuple: Coordinates of the midpoint
    """
    if not points:
        raise ValueError("At least one point required")
    
    dimensions = len(points[0])
    if not all(len(p) == dimensions for p in points):
        raise ValueError("All points must have same dimensions")
    
    result = []
    for dim in range(dimensions):
        avg = sum(p[dim] for p in points) / len(points)
        result.append(avg)
    
    return tuple(result)


def normalize_vector(vector: Tuple) -> Tuple:
    """
    Normalize a vector to unit length.
    
    Args:
        vector: Vector coordinates
        
    Returns:
        Tuple: Normalized vector
    """
    mag = math.sqrt(sum(v ** 2 for v in vector))
    if mag == 0:
        raise ValueError("Cannot normalize zero vector")
    return tuple(v / mag for v in vector)


def dot_product(v1: Tuple, v2: Tuple) -> float:
    """
    Calculate dot product of two vectors.
    
    Args:
        v1: First vector
        v2: Second vector
        
    Returns:
        float: Dot product result
    """
    if len(v1) != len(v2):
        raise ValueError("Vectors must have same dimensions")
    return sum(a * b for a, b in zip(v1, v2))


def interpolate(point1: Tuple, point2: Tuple, t: float) -> Tuple:
    """
    Linear interpolation between two points.
    
    Args:
        point1: Start point
        point2: End point
        t: Interpolation parameter (0.0 to 1.0)
        
    Returns:
        Tuple: Interpolated point
    """
    if len(point1) != len(point2):
        raise ValueError("Points must have same dimensions")
    
    if not 0.0 <= t <= 1.0:
        raise ValueError("Parameter t must be between 0.0 and 1.0")
    
    return tuple(p1 + (p2 - p1) * t for p1, p2 in zip(point1, point2))


def point_on_line(point: Tuple, line_start: Tuple, line_end: Tuple, tolerance: float = 0.001) -> bool:
    """
    Check if a point lies on a line segment.
    
    Args:
        point: Point to check
        line_start: Start of line segment
        line_end: End of line segment
        tolerance: Maximum distance from line to consider point on line
        
    Returns:
        bool: True if point is on the line
    """
    # Calculate distance from point to line using projection
    line_vec = tuple(e - s for s, e in zip(line_start, line_end))
    point_vec = tuple(p - s for p, s in zip(point, line_start))
    
    line_len_sq = sum(v ** 2 for v in line_vec)
    if line_len_sq == 0:
        return distance(point, line_start) <= tolerance
    
    t = dot_product(point_vec, line_vec) / line_len_sq
    t = max(0.0, min(1.0, t))
    
    closest_point = interpolate(line_start, line_end, t)
    return distance(point, closest_point) <= tolerance


def rotate_point_2d(point: Tuple[float, float], center: Tuple[float, float], angle: float) -> Tuple[float, float]:
    """
    Rotate a 2D point around a center by an angle (in radians).
    
    Args:
        point: Point to rotate
        center: Center of rotation
        angle: Rotation angle in radians
        
    Returns:
        Tuple: Rotated point coordinates
    """
    x, y = point
    cx, cy = center
    
    cos_a = math.cos(angle)
    sin_a = math.sin(angle)
    
    # Translate to origin
    x -= cx
    y -= cy
    
    # Rotate
    new_x = x * cos_a - y * sin_a
    new_y = x * sin_a + y * cos_a
    
    # Translate back
    return (new_x + cx, new_y + cy)


def bounding_box(*points: Tuple) -> Tuple[Tuple, Tuple]:
    """
    Calculate bounding box for multiple points.
    
    Args:
        *points: Variable number of points
        
    Returns:
        Tuple: ((min_coords), (max_coords))
    """
    if not points:
        raise ValueError("At least one point required")
    
    dimensions = len(points[0])
    if not all(len(p) == dimensions for p in points):
        raise ValueError("All points must have same dimensions")
    
    mins = list(points[0])
    maxs = list(points[0])
    
    for point in points[1:]:
        for dim, coord in enumerate(point):
            if coord < mins[dim]:
                mins[dim] = coord
            if coord > maxs[dim]:
                maxs[dim] = coord
    
    return (tuple(mins), tuple(maxs))


def points_in_bbox(points: List[Tuple], bbox: Tuple[Tuple, Tuple]) -> List[Tuple]:
    """
    Filter points that are within a bounding box.
    
    Args:
        points: List of points to filter
        bbox: Bounding box ((min_coords), (max_coords))
        
    Returns:
        List: Points within the bounding box
    """
    mins, maxs = bbox
    result = []
    
    for point in points:
        in_bbox = True
        for coord, min_val, max_val in zip(point, mins, maxs):
            if not (min_val <= coord <= max_val):
                in_bbox = False
                break
        if in_bbox:
            result.append(point)
    
    return result
